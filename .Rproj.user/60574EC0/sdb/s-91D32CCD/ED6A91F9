{
    "collab_server" : "",
    "contents" : "#REMEMBER TO DEAL WITH BAG3 VARIANTS!\n\nlibrary(MSstats)\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(pheatmap)\n\n\n####UTILIZING SAINTQ OUTPUTS####\n#Load Saintq output files\nsaintqScores<-read.delim(\"./SetA+B+C+D_Fusion/saintq/\", header=T, stringsAsFactors = F)\nsaintqScores[grepl(\"O95817\",saintqScores$Prey),'Prey']<-'O95817'#To deal with BAG3 variants\n\ncutoff<-0.1 #Cutoff for the FDR\n\n#When passing to matrix form, using fun.aggregate=min deals with multiple values for BAG3,\n#while keeping missing values as 1 (for fillers)\nbfdrMatrix<-dcast(saintqScores, formula = Prey ~ Bait, value.var = \"BFDR\", drop=F, fun.aggregate=min, na.rm=T, fill = 0) #casting to matrix form\npeptMatrix<-dcast(saintqScores, formula = Prey ~ Bait, value.var = \"X.Pep\", drop=F, fun.aggregate=min, na.rm=T, fill = 0) #casting to matrix form\nrow.names(bfdrMatrix)<-bfdrMatrix[,1]; bfdrMatrix<-bfdrMatrix[,-which(names(bfdrMatrix) %in% c(\"Prey\"))]\nrow.names(peptMatrix)<-peptMatrix[,1]; peptMatrix<-peptMatrix[,-which(names(peptMatrix) %in% c(\"Prey\"))]\n\n#How many significant interactors for each prey?\nsaintqScores$Significant<-saintqScores$BFDR<=cutoff\npng(paste(\"./#SignificantHits_FDR\", cutoff, \".png\", sep=\"\"))\np<-ggplot(saintqScores, aes(x=Bait, fill=factor(Significant)))\np+geom_bar()+labs(title=paste(\"# Significant hits with FDR below\", cutoff), x=\"Bait\") #plotting it\ndev.off()\nsigTable<-apply(bfdrMatrix, MARGIN = 2, function(x) table(x<=cutoff)) #In table form\nwrite.table(sigTable, paste(\"./#SignificantHits_FDR\", cutoff, \".txt\", sep=\"\"), quote=F, sep=\"\\t\")\n\n\n#A matrix with all interactors that are significant for at least one of the baits\noneSignificant<-apply(bfdrMatrix, MARGIN = 1, function(x) any(x<=0.05, na.rm = T))#the names\nbfdrMatrixSig<-bfdrMatrix[oneSignificant==TRUE,]\n\n#a subset that contains entries depending on only 1 or 2 peptides (to be handled carefully)\n#note: I do those that contain 1 or 2 entries in all of them - otherwise they are kept normally\npeptMatrixSig<-peptMatrix[row.names(peptMatrix) %in% row.names(bfdrMatrixSig),]\nlowPept<-apply(peptMatrixSig, MARGIN = 1, function(x) all(x<=2, na.rm = T))#the names\nbfdrLowPeptMatrix<-bfdrMatrixSig[lowPept==TRUE,]\nlowPeptMatrixSig<-peptMatrixSig[lowPept==TRUE,]\n\n\n\n\n##BFDRLOWPEPTMATRIX IS THE ONE WITH SIGNIFICANT PROTEINS IDENTIFIED BY ONLY FEW PEPTIDES\n##BFDRMATRIXSIG IS THE ONE WITH SIGNIFICANT PROTEINS (ALL)\n\n\n####MSSTATS PROCESSING####\n\n#Setup Files\n#NOTE: using the ones from the \nevidence<-read.table(\"./SetA+B+C+D_Fusion/txt/evidence.txt\", sep=\"\\t\", \n                    header=T, stringsAsFactors = F)\n\nannot<-read.table(\"./SetA+B+C+D_Fusion/annotation.txt\", sep=\"\\t\", \n                  header=T, stringsAsFactors = F) #file is made from the make_annotation custom function.\n\n#Using \"annot2\" every sample is treated separately.\n#annot2 <- annot\n#annot2$Condition <- paste(annot2$Condition, \"_#\", 1:nrow(annot2), sep=\"\")\n\nproteinGroups<-read.table(\"./SetA+B+C+D_Fusion/txt/proteinGroups.txt\", sep=\"\\t\", \n                           header=T, stringsAsFactors = F)\n\n#Uniprot database. for naming et al\nuniprot<-read.delim(\"~/Protein_Databases/Uniprot_human_Jul2016/uniprot_singleID.txt\",\n                    header = TRUE, stringsAsFactors = F)\n\n\n#Filtering (or not) the evidence entries to those associated with SAINTq significant hits\n# infileSig<-infile2[infile2$Leading.razor.protein %in% row.names(bfdrMatrixSig),]\n# print(paste(\"Number of unique proteins in total: \", length(unique(infile2$Leading.razor.protein))))\n# print(paste(\"Number of unique *significant* proteins in total: \", length(unique(infileSig$Leading.razor.protein))))\n\n\nmsStatsInput<-MaxQtoMSstatsFormat(evidence = evidence, annotation = annot, \n                                  proteinGroups = proteinGroups)\n\n#OPTIONAL: narrow down to only CM samples of interest\nmsStatsInput <- msStatsInput[!grepl(\"iPS_|HSPB7|RBM20\", msStatsInput$Condition),]\n\n# msStatsInputSig<-MaxQtoMSstatsFormat(evidence = infileSig, annotation = annot, \n#                                      proteinGroups = proteinGroups)\n\n\n####MSSTATS PROCESSING####\n\n###STEP 1 - dataProcess\n#Run DataProcess. All hits\n#msStatsProc_medianNorm<-dataProcess(msStatsInput) #default options\nmsStatsProc_noNorm<-dataProcess(msStatsInput, normalization = FALSE,\n                                cutoffCensored = \"minFeature\", summaryMethod = \"TMP\", \n                                equalFeatureVar = FALSE, MBimpute = TRUE,\n                                fillIncompleteRows = TRUE)\n\nmsStatsProc_medianNorm<-dataProcess(msStatsInput, normalization = 'equalizeMedians', \n                                  cutoffCensored = \"minFeature\", summaryMethod = \"TMP\",\n                                  equalFeatureVar = TRUE, MBimpute = TRUE,\n                                  fillIncompleteRows = TRUE)\n\n#For normalization on global standards (BAG3), limit it to the ions that are (a) not present in the control (one rep has a few there) \n#and (b) present in all others (NOTE: this excluded by now) and (c) not phosphorylated (NOTE: not used, as it seemed to throw off normalization)\nbag3Peptides <- msStatsInput[msStatsInput$ProteinName==\"O95817\" & !is.na(msStatsInput$Intensity),]\nbag3PeptidesPhosphorylated <- bag3Peptides[grepl(pattern = \"\\\\(ph\\\\)\", x = bag3Peptides$PeptideSequence),]\nbag3PeptidesPhosphorylated <- gsub(pattern = \"\\\\(ph\\\\)\", replacement = \"\", x = bag3PeptidesPhosphorylated$PeptideSequence)#only the sequence\nbag3PeptidesInControl <- bag3Peptides[bag3Peptides$Condition==\"WTc11\",\"PeptideSequence\"]\nbag3Peptides <- bag3Peptides[!bag3Peptides$PeptideSequence %in% bag3PeptidesInControl,]#removes those in control\nbag3Peptides <- bag3Peptides[!bag3Peptides$PeptideSequence %in% bag3PeptidesPhosphorylated,]#removes those with phosphorylation\nbag3Peptides$PeptideSequenceCharge <- paste(bag3Peptides$PeptideSequence, bag3Peptides$PrecursorCharge, sep=\"_\")\nbag3PeptideStandards <- as.vector(unique(droplevels(bag3Peptides$PeptideSequence)))\n\nmsStatsProc_baitNorm<-dataProcess(msStatsInput, normalization = 'globalStandards', nameStandards = bag3PeptideStandards, \n                                    cutoffCensored = \"minFeature\", summaryMethod = \"TMP\",\n                                    equalFeatureVar = TRUE, MBimpute = TRUE,\n                                    fillIncompleteRows = TRUE)\n\n#Run DataProcess. Only significant hits\n# msStatsProcSig_noNorm<-dataProcess(msStatsInputSig, normalization = FALSE,\n#                                    nameStandards=\"O95817\", cutoffCensored = \"minFeature\",\n#                                    summaryMethod = \"TMP\", equalFeatureVar = FALSE, MBimpute = TRUE,\n#                                    fillIncompleteRows = TRUE)\n# msStatsProcSig_baitNorm<-dataProcess(msStatsInputSig, normalization = 'globalStandards', \n#                                      nameStandards=\"O95817\", cutoffCensored = \"minFeature\",\n#                                      summaryMethod = \"TMP\", equalFeatureVar = FALSE, MBimpute = TRUE,\n#                                      fillIncompleteRows = TRUE)\n\n\n#Plots - all hits\ndir.create(\"./msStats/\", showWarnings = TRUE)\ndataProcessPlots(msStatsProc_noNorm, type = \"ProfilePlot\", address = \"./msStats/BAG3_noNormalized\", \n                 which.Protein = \"O95817\", save_condition_plot_result = T, text.size=2) #per protein Plot with intensities\ndataProcessPlots(msStatsProc_noNorm, type = \"QCPlot\", address = \"./msStats/BAG3_noNormalized\", \n                 text.size = 2, which.Protein = \"O95817\") #Quality control Plot\n\ndir.create(\"./msStats/\", showWarnings = TRUE)\ndataProcessPlots(msStatsProc_medianNorm, type = \"ProfilePlot\", address = \"./msStats/BAG3_medianNorm\", \n                 which.Protein = \"O95817\", save_condition_plot_result = T, text.size=2) #per protein Plot with intensities\ndataProcessPlots(msStatsProc_medianNorm, type = \"QCPlot\", address = \"./msStats/BAG3_medianNorm\", \n                 which.Protein = \"O95817\", text.size = 2) #Quality control Plot\n\ndataProcessPlots(msStatsProc_baitNorm, type = \"ProfilePlot\", address = \"./msStats/BAG3_baitNorm\", \n                 which.Protein = \"O95817\", save_condition_plot_result = T, text.size=2) #per protein Plot with intensities\ndataProcessPlots(msStatsProc_baitNorm, type = \"QCPlot\", address = \"./msStats/BAG3_baitNorm\", \n                 which.Protein = \"O95817\", text.size = 2) #Quality control Plot\n\n# #Plots - only significant hits\n# dir.create(\"./plots_sig_noNorm\", showWarnings = TRUE)\n# dataProcessPlots(msStatsProcSig_noNorm, type = \"ProfilePlot\", address = \"./plots_sig_noNorm/\") #per protein Plot with intensities\n# dataProcessPlots(msStatsProcSig_noNorm, type = \"QCPlot\", address = \"./plots_sig_noNorm/\") #Quality control Plot\n# \n# dir.create(\"./plots_sig_baitNorm\", showWarnings = TRUE)\n# dataProcessPlots(msStatsProcSig_baitNorm, type = \"ProfilePlot\", address = \"./plots_sig_baitNorm/\") #per protein Plot with intensities\n# dataProcessPlots(msStatsProcSig_baitNorm, type = \"QCPlot\", address = \"./plots_sig_baitNorm/\") #Quality control Plot\n\n\n\n###STEP 1.5 - QC of samples\n#Clustering of samples (NOTE that this is only for the 'significant' hits from SAINTq!)\nsampledf<-msStatsProc_medianNorm$ProcessedData\nsampledf$SAMPLE<-paste(sampledf$GROUP_ORIGINAL, sampledf$RUN, sep = \"_\")\nsampleMatrix<-dcast(data = sampledf, FEATURE ~ SAMPLE, \n                    value.var = \"ABUNDANCE\", drop = FALSE)\nrownames(sampleMatrix)<-sampleMatrix$FEATURE\nsampleMatrix<-sampleMatrix[-1]\nsampleMatrix_cor <- cor(sampleMatrix, use=\"pairwise.complete.obs\", method=\"pearson\")\npheatmap(sampleMatrix_cor)\n\n\n#Checking BAG3 total counts. NOTE: QC plots from MSSTATS are better!\nsampledfBAG3<-sampledf[sampledf$PROTEIN==\"O95817\",]\nsampledfBAG3$PROTEIN<-factor(sampledfBAG3$PROTEIN)\nsampledfBAG3$FEATURE<-factor(sampledfBAG3$FEATURE)\nsampleMatrixBAG3<-dcast(data = sampledfBAG3, PROTEIN ~ SAMPLE, \n                        value.var = \"ABUNDANCE\", drop = FALSE, fun.aggregate = sum, na.rm=T)\nrownames(sampleMatrixBAG3)<-sampleMatrixBAG3$PROTEIN\nsampleMatrixBAG3<-t(sampleMatrixBAG3[-1])\nsampleMatrixBAG3<-as.data.frame(sampleMatrixBAG3)\n#sampleMatrixBAG3_cor <- cor(sampleMatrixBAG3, use=\"pairwise.complete.obs\", method=\"pearson\")\ng<-ggplot(data = sampleMatrixBAG3, aes(x=row.names(sampleMatrixBAG3), y=O95817))+\n    geom_bar(stat=\"Identity\")+theme(axis.text.x=element_text(angle=90,hjust=1,vjust=0.5))\ng\n\n\n###STEP 2 - GROUP COMPARISONS\n#checkLevels\nlevels(msStatsProc_noNorm$ProcessedData$GROUP_ORIGINAL)\n\n#Define which comparisons I want\ncomparisonTemplate <- rep(0, length(levels(msStatsProc_noNorm$ProcessedData$GROUP_ORIGINAL)))\ncomparison_A4vsCMcontrol <- matrix(c(1, 0, 0, 0, 0, 0, 0, -1), nrow=1)\ncomparison_homoDMSOvsCMcontrol <- matrix(c(0, 0, 0, 1, 0, 0, 0, -1), nrow=1)\ncomparison_homoDMSOvsTetOnBAG3 <- matrix(c(0, 0, 0, 1, 0, 0, -1, 0), nrow=1)\n\ncomparison<-rbind(comparison_A4vsCMcontrol, comparison_homoDMSOvsCMcontrol, comparison_homoDMSOvsTetOnBAG3)\nrow.names(comparison)<- c(\"comparison_A4vsCMcontrol\", \"comparison_homoDMSOvsCMcontrol\", \"comparison_homoDMSOvsTetOnBAG3\")\nmsStatsComparison<-groupComparison(comparison, data=msStatsProc_noNorm)\n\n\n###STEP 2.5 - QC of comparisons\n#Volcano Plot\n#compDataFilt<-compData[is.na(compData$issue),]\n\ngroupComparisonPlots(data= msStatsComparison$ComparisonResult, type=\"VolcanoPlot\", address = \"VolcanoPlotTest.pdf\", sig = 0.2)\n\n#Heat Map\ngroupComparisonPlots(data=msStatsComparison$ComparisonResult,  type=\"Heatmap\")\n",
    "created" : 1509057924056.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3467755441",
    "id" : "ED6A91F9",
    "lastKnownWriteTime" : 1512118710,
    "last_content_update" : 1512118710046,
    "path" : "~/Documents/Projects/finalAPMS_analysis/process4MSStats_3.R",
    "project_path" : "process4MSStats_3.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}